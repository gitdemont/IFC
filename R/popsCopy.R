#' @title Copy Populations Fomr One File to Another File
#' @description
#' Copies populations from a DAF file into a copy of another DAF file.
#' Only creates new file with copied population.
#' @param from path to file to copy populations from.
#' @param into path to file that will be used as a template to copy population into.
#' Caution, it is mandatory that 'into' contains 'from' starting at 'offset'.
#' @param export_to Pattern used to export file.
#' Placeholders, like "\%d/\%s_fromR.\%e", will be substituted:\cr
#' -\%d: with full path directory of 'into'\cr
#' -\%p: with first parent directory of 'into'\cr
#' -\%e: with extension of 'into' (without leading .)\cr
#' -\%s: with shortname from 'into' (i.e. basename without extension).\cr
#' Exported file extension will be deduced from this pattern. Note that it has to be a .daf.
#' @param pops regular expression or vector of desired populations present in 'from'.\cr
#' If missing, the default, all populations found will be copied.\cr
#' If given but not found, a warning will be sent.
#' @param use_regex whether to use regex to pick up population into 'from'. Default is FALSE.
#' @param overwrite whether to overwrite existing file or not. Default is FALSE.
#' Note that if TRUE, it will overwrite exported file if path of 'into' and deduced from 'export_to' arguments are different.
#' Otherwise, you will get an error saying that overwritting source file is not allowed.\cr
#' Note also that an original file, i.e. generated by IDEAS(R) or INSPIRE(R), will never be overwritten.
#' Otherwise, you will get an error saying that overwritting original file is not allowed.\cr
#' @param append_name whether to append_name basename(from) to exported populations. Default is TRUE.
#' @param offset Object number of 1st object of 'from' in 'into'. Default is 0.
#' @param endianness The endian-ness ("big" or "little") of the target system for the file. Default is .Platform$endian.
#' @param verbose whether to display information (use for debugging purpose). Default is FALSE.
#' @param ... Other arguments to be passed.
#' @details Populations are exported as tagged populations.
#' @return a new file is created containing exported populations.\cr
#' It invisibly returns full path of exported file.
#' @export
popsCopy = function(from, into, export_to, pops, use_regex = FALSE, overwrite = FALSE, append_name = TRUE, offset = 0, endianness = .Platform$endian, verbose = FALSE, ...) {
  dots = list(...)
  if(missing(from)) stop("'from' can't be missing")
  if(missing(into)) stop("'into' can't be missing")
  f_Ext = getFileExt(from); assert(f_Ext, len=1, alw="daf")
  i_Ext = getFileExt(into); assert(i_Ext, len=1, alw="daf")
  if(!file.exists(from)) stop(paste("can't find",from,sep=" "))
  if(!file.exists(into)) stop(paste("can't find",into,sep=" "))
  if(missing(export_to)) stop("'export_to' can't be missing")
  assert(export_to, len = 1, typ = "character")
  if(file.exists(export_to)) if(!overwrite) stop(paste0("file ",export_to," already exists"))
  use_regex = as.logical(use_regex); assert(use_regex, len = 1, alw = c(TRUE, FALSE))
  overwrite = as.logical(overwrite); assert(overwrite, len = 1, alw = c(TRUE, FALSE))
  append_name = as.logical(append_name); assert(append_name, len = 1, alw = c(TRUE, FALSE))
  offset = na.omit(as.integer(offset)); offset = offset[offset>=0]
  assert(offset, len = 1, typ = "integer")
  assert(endianness, len = 1, alw= c("big", "little"))
  verbose = as.logical(verbose); assert(verbose, len = 1, alw = c(TRUE, FALSE))
  
  daf = ExtractFromDAF(fileName = from, extract_features = TRUE, extract_images = FALSE, extract_offsets = FALSE, extract_stats = FALSE, endianness = endianness)
  obj_number = as.numeric(getDisplayInfo(fileName = into)$objcount)
  if(verbose) print(names(daf$pops))
  if(missing(pops)) {
    pops = names(daf$pops)
  } else {
    if(use_regex) pops = names(daf$pops)[grepl(pops, names(daf$pops))]
    tmp = pops%in%names(daf$pops)
    if(!all(tmp)) warning(paste0("Some pops are not present in 'from' file:\n", paste0(pops[!tmp], collapse="\n")))
  }
  pops = daf$pops[pops]
  pops = lapply(pops, FUN=function(x) {
    if(append_name) x$name <- paste(x$name, basename(from), sep="_")
    x$type <- "T"
    K = class(x$obj)
    x$obj <- which(x$obj) + offset - 1
    x$obj = x$obj[x$obj %in% (0:(obj_number-1))]
    return(x)
  })
  ExportToDAF(fileName = into, export_to = export_to, pops = pops, endianness = endianness, verbose = verbose, overwrite = overwrite)
}
