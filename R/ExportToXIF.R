#' @title RIF/CIF File Subsetting
#' @description
#' Subsets RIF or CIF files.
#' @param fileName path of file to read data from.
#' It has to be a '.rif' or '.cif' file.
#' @param export_to Pattern used to export file.
#' Placeholders, like "\%d/\%s_fromR.\%e", will be substituted:\cr
#' -\%d: with full path directory of 'fileName'\cr
#' -\%p: with first parent directory of 'fileName'\cr
#' -\%e: with extension of 'fileName' (without leading .)\cr
#' -\%s: with shortname from 'fileName' (i.e. basename without extension).\cr
#' Exported file extension will be deduced from this pattern. It has to be the same as 'fileName', i.e. .cif or .rif.
#' @param objects integers, indices of objects to use. If missing, the default, all objects will be used.
#' @param offsets Object of class IFC_offsets. If missing, the default, offsets will be extracted from fileName.\cr
#' This param is not mandatory but it may allow to save time for repeated XIF export on same file.
#' @param fast whether to fast extract objects or not. Default is TRUE.
#' Meaning that 'objects' will be extracting expecting that raw object are stored in ascending order.
#' Note that a warning will be sent if an 'object' is found at an unexpected order.
#' In such a case you may need to rerun function with 'fast' = FALSE.
#' If set to FALSE, all raw object_ids will be scanned from 'fileName' to ensure extraction of desired 'objects'.
#' IMPORTANT: whatever this argument is, features are extracted assuming an ascending order of storage in raw file.
#' @param extract_features whether to try to extract features. Default is FALSE.
#' @param endianness The endian-ness ("big" or "little") of the target system for the file. Default is .Platform$endian.
#' @param verbose whether to display information (use for debugging purpose). Default is FALSE.
#' @param verbosity quantity of information displayed when verbose is TRUE; 1: normal, 2: rich. Default is 1.
#' @param overwrite whether to overwrite file or not. Default is FALSE.\cr
#' Note that if TRUE, it will overwrite exported file if path of 'fileName' and deduced from 'export_to' arguments are different.
#' Otherwise, you will get an error saying that overwritting source file is not allowed.\cr
#' Note also that an original file, i.e. generated by IDEAS(R) or INSPIRE(R), will never be overwritten.
#' Otherwise, you will get an error saying that overwritting original file is not allowed.\cr
#' @param display_progress whether to display a progress bar. Default is TRUE.
#' @param ... Other arguments to be passed.
#' @details Only features stored in binary format will be extracted if found.
#' If the input fileName is a merged of several files then features will be extracted from these files.\cr
#' If file(s) can't be found, Warning(s) will be thrown and input fileName will be extracted without features values.
#' @examples
# #' \dontrun{
#' if(requireNamespace("IFCdata", quietly = TRUE)) {
#'   tmp <- tempdir(check = TRUE)
#'   ## use a cif file, but you can also subset rif
#'   file_cif <- system.file("extdata", "example.cif", package = "IFCdata")
#'   ## Extract display information from file
#'   disp <- getDisplayInfo(file_cif)
#'   ## show the "img" 5st objects within file
#'   DisplayGallery(display = disp, objects = 0:4, export_to = "example.png")
#'   ## subset "img" object 0,1 and 4 from file
#'   exported <- ExportToXIF(fileName = file_cif, export_to = paste0(tmp, "\\test.cif"),
#'                           overwrite = TRUE, objects = c(0,1,4))
#'   ## Display all "img" objects in exported file
#'   DisplayGallery(display = getDisplayInfo(exported), export_to = "example.png")
#' } else {
#'   message(sprintf('Please type `install.packages("IFCdata", repos = "%s", type = "source")` %s',
#'                   'https://gitdemont.github.io/IFCdata/',
#'                   'to install extra files required to run this example.'))
#' }
# #' }
#' @return It invisibly returns full path of exported file.
#' @export
ExportToXIF <- function (fileName, export_to, objects, offsets, fast = TRUE, 
                         extract_features = FALSE, endianness = .Platform$endian, verbose = FALSE, verbosity = 1, 
                         overwrite = FALSE, display_progress = TRUE, ...) {
  dots = list(...)
  # change locale
  locale_back = Sys.getlocale("LC_ALL")
  on.exit(Sys.setlocale("LC_ALL", locale_back), add = TRUE)
  Sys.setlocale("LC_ALL", "en_US.UTF-8")
  
  # check madatory param
  if(missing(fileName)) stop("'fileName' can't be missing")
  if(!file.exists(fileName)) stop(paste("can't find", fileName, sep = " "))
  if(missing(export_to)) stop("'export_to' can't be missing")
  extract_features = as.logical(extract_features); assert(extract_features, len = 1, alw = c(TRUE, FALSE))
  display_progress = as.logical(display_progress); assert(display_progress, len = 1, alw = c(TRUE, FALSE))
  if(display_progress) {
    if(.Platform$OS.type == "windows") {
      pb_fun = setWinProgressBar
    } else {
      pb_fun = setTxtProgressBar
    }
  }
  r_endian = cpp_checkTIFF(fileName)
  f_Ext = getFileExt(fileName)
  fileName = normalizePath(fileName, winslash = "/", mustWork = FALSE)
  assert(export_to, len = 1, typ = "character")
  splitf_obj = splitf(fileName)
  splitp_obj = splitp(export_to)
  export_to = formatn(splitp_obj, splitf_obj)
  e_Ext = getFileExt(export_to); assert(e_Ext, len = 1, alw = c("cif", "rif"))
  if(f_Ext != e_Ext) stop("'fileName' and 'export_to' should have same extension")
  if(any(splitp_obj$channel > 0)) message("'export_to' has %c argument but channel information can't be retrieved with ExportToXIF()")
  if(any(splitp_obj$object > 0)) message("'export_to' has %o argument but channel information can't be retrieved with ExportToXIF()")
  dir_name = dirname(export_to)
  if(!dir.exists(dir_name)) if(!dir.create(dir_name, recursive = TRUE, showWarnings = FALSE)) stop(paste0("can't create\n", dir_name))
  
  overwritten = FALSE
  if(file.exists(export_to)) {
    export_to = normalizePath(export_to, winslash = "/", mustWork = FALSE)
    if(!overwrite) stop(paste0("file ", export_to, " already exists"))
    if(tolower(fileName) == tolower(export_to)) stop("you are trying to overwrite source file which is not allowed")
    IFD_export = getIFD(fileName = export_to, offsets = "first", force_trunc = FALSE, trunc_bytes = 8, verbose = FALSE)[[1]] 
    if(length(IFD_export$tags[["33090"]])==0) stop("you are trying to overwrite an original file which is not allowed")
    tmp_file = tempfile()
    overwritten = TRUE
  }
  file_w = ifelse(overwritten, tmp_file, export_to)

  # Extract important values
  IFD = getIFD(fileName = fileName, offsets = "first", force_trunc = FALSE, trunc_bytes = 8, verbose = FALSE)[[1]] 
  nobj = IFD$tags[["33018"]]$map
  is_binary = as.logical(IFD$tags[["33082"]]$map)
  if(length(is_binary) == 0) is_binary = FALSE
  V = NULL
  Files = fileName
  if(!is.null(IFD$tags[["33029"]])) 
    if(IFD$tags[["33029"]]$byt != 0)
      V = strsplit(as.character(getFullTag(fileName, IFD, tag="33029")), "|", fixed = TRUE)[[1]]
  
  # Merged RIF Files
  if(!is.null(IFD$tags[["33030"]])) 
    if(IFD$tags[["33030"]]$byt != 0)
      V = strsplit(as.character(getFullTag(fileName, IFD, tag="33030")), "|", fixed = TRUE)[[1]]
  
  if(length(V) > 1) Files = normalizePath(paste(dirname(fileName), basename(V), sep = "/"), winslash = "/", mustWork = FALSE)
  
  if(missing(objects)) {
    message("\nAll objects will be extracted\n")
    objects = as.integer(0:(nobj - 1))
  } else {
    objects = as.integer(objects)
    tokeep = (objects >= 0) & (objects < nobj)
    if(length(tokeep) == 0) {
      warning(paste0("ExportToXIF: No objects to export, check the objects you provided.\n",
                     "Can't create 'export_to' file.\n", export_to),
              immediate. = TRUE, call. = FALSE)
      return(invisible(NULL))
    }
    if(!all(tokeep)) {
      objects = unique(objects[tokeep]) # unique is very important
      warning("Some objects that are not in ", fileName, " have been automatically removed from extraction process")
    }
    objects = objects[order(objects)] # since it appears that objects are stored with increasing number
  }
  
  compute_offsets = TRUE
  if(!missing(offsets)) {
    if(!("IFC_offsets" %in% class(offsets))) {
      warning("provided offsets do not match with expected ones, offsets will be recomputed", immediate. = TRUE, call. = FALSE)
    } else {
      if(attr(offsets, "checksum") != checksumXIF(fileName)) {
        warning("provided offsets do not match with expected ones, offsets will be recomputed", immediate. = TRUE, call. = FALSE)
      } else {
        compute_offsets = FALSE
      }
    }
  }
  if(compute_offsets) {
    offsets = suppressMessages(getOffsets(fileName = fileName, fast = fast, display_progress = display_progress))
  }
  
  # Initializes values
  obj_id = - 1
  L = length(objects)
  objects_1 = objects + 1
  offsets = subsetOffsets(offsets = offsets, objects = objects, objects_type = c("img", "msk"))
  offsets = c(IFD$curr_IFD_offset, offsets)
  
  off_number = length(offsets)
  # unwanted tags
  # 33029 corresponds to merged files in CIF, will be removed since new subset file can't contain this tag
  # 33030 corresponds to merged files in RIF, will be removed since new subset file can't contain this tag
  # 33080 corresponds to offset of Features values, will be overwritten if features are found
  # 33082 corresponds to binary Features version, will be overwritten if features are found
  # 33083 corresponds to offset of Features values in merged
  unwanted = c(33029, 33030, 33080, 33082, 33083)
  
  # tags of StripOffsets (273) and TileOffsets (324)
  off_tags = c(273, 324)
  
  # opens connections for reading and writing
  toread = file(description = fileName, open = "rb")
  on.exit(close(toread), add = TRUE)
  tryCatch(suppressWarnings({
    towrite = file(description = file_w, open = "wb")
  }), error = function(e) {
    stop(paste0(ifelse(overwritten,"temp ","'export_to' "), "file: ", file_w, "\ncan't be created: check name ?"))
  })
  export_to = normalizePath(export_to, winslash = "/", mustWork = FALSE)
  tryCatch(expr = {
    # goes to beginning of file
    seek(toread, 0)
    # reads and writes magick number
    writeBin(object = readBin(toread, what = "raw", n = 4, endian = r_endian), con = towrite, endian = r_endian)
    # defines writing position
    pos = 4
    
    if(display_progress) {
      if(.Platform$OS.type == "windows") {
        pb1 = winProgressBar(title = basename(fileName), label = "information in %", min = 0, max = 100, initial = 1)
      } else {
        pb1 = txtProgressBar(title = basename(fileName), label = "information in %", min = 0, max = 100, initial = 1, style = 3)
      }
      on.exit(close(pb1), add = TRUE)
    }
    for(i_off in 1:off_number) {
      curr_obj = cpp_getTAGS(fname = fileName, offset = offsets[i_off], trunc_bytes = 8, force_trunc = FALSE, verbose = FALSE)$infos
      if(length(curr_obj$OBJECT_ID) == 1) {
        if(fast) {
          expected_obj = as.integer(gsub("^.*_(.*)$", "\\1", names(offsets[i_off])))
          if(curr_obj$TYPE == 2) if(curr_obj$OBJECT_ID != expected_obj) {
            warning("Extracted object_id [",curr_obj$OBJECT_ID,"] differs from expected one [",expected_obj,"]", call. = FALSE, immediate. = TRUE)
          }
        }
      }
      if(display_progress) {
        k1=(obj_id+1)/L*50
        pb_fun(pb1, value = k1, label = sprintf("Objects extraction %.0f%%", k1))
      }
      # extracts IFD
      IFD = cpp_getTAGS(fname = fileName, offset = offsets[i_off], trunc_bytes = 8, force_trunc = FALSE, verbose = FALSE)
      # go to file IFD offset
      seek(toread, offsets[i_off])
      
      # read number of directory entries
      readBin(toread, what = "raw", n = 2, endian = r_endian)
      ifd = sapply(IFD$tags, simplify = FALSE, FUN=function(i_tag) {
        add_content = raw()
        # read entry
        min_content = readBin(toread, what = "raw", n = 12, endian = r_endian)
        # register current position in read
        r_pos = seek(toread)
        # removes unwanted tags
        if(i_tag$tag %in% unwanted) return(list(min_content = raw(), add_content = raw()))
        # extracts extra content when value is an offset
        if(i_tag$off | (i_tag$tag %in% off_tags)) {
          # go to this offset in read
          seek(toread, i_tag$val)
          # extra content
          if(i_tag$tag %in% off_tags) {
            if(i_tag$tag == 273) add_content = readBin(toread, what = "raw", n = IFD$tags[["279"]]$val, endian = r_endian)
            if(i_tag$tag == 324) add_content = readBin(toread, what = "raw", n = IFD$tags[["325"]]$val, endian = r_endian)
          } else {
            add_content = readBin(toread, what = "raw", n = i_tag$byt, endian = r_endian)
          }
          # go to former position in read
          seek(toread, r_pos)
        }
        return(list(min_content = min_content, add_content = add_content))
      })
      # removes unwanted tags
      ifd = ifd[sapply(ifd, FUN=function(i_tag) length(i_tag$min_content)!=0)]
      
      # extracts features values in 1st IFD
      if(IFD$infos$TYPE == 1) {
        features = list()
        if(extract_features) {
          tryCatch({
            obj_shift = 0
            for(f in Files) {
              if(!file.exists(f)) {
                features = list()
                stop(f, "\nCan't find file")
              }
              toread2 = file(f, open = "rb")
              tryCatch({
                IFD_f = getIFD(fileName = f, offsets = "first", trunc_bytes = 8, force_trunc = FALSE, verbose = FALSE)[[1]]
                is_binary = as.logical(IFD_f$tags[["33082"]]$map)
                if(length(is_binary) == 0) is_binary = FALSE
                if(!is_binary) {
                  features = list()
                  stop(f, "\nCan't deal with non-binary features")
                }
                
                seek(toread2, ifelse(length(IFD_f$tags[["33080"]]$val)==0, stop("can't find pointer '33080' to extract features"), IFD_f$tags[["33080"]]$val))
                obj_number_r = readBin(toread2, what = "raw", n = 4, endian = r_endian)
                obj_number = readBin(obj_number_r, what = "double", size = 4, n = 1, endian = r_endian)
                feat_number_r = readBin(toread2, what = "raw", n = 4, endian = r_endian)
                feat_number = readBin(feat_number_r, what = "double", size = 4, n = 1, endian = r_endian)

                if((length(obj_number) == 0) | (length(feat_number) == 0)) {
                  features = list()
                  stop(f, "\nBinary features is of length 0")
                }
                if(IFD_f$tags[["33018"]]$val != obj_number) {
                  features = list()
                  stop(f, "\nMismatch in object number")
                }

                if(display_progress) {
                  if(.Platform$OS.type == "windows") {
                    pb3 = winProgressBar(title = basename(f), label = "information in %", min = 0, max = 100, initial = 1)
                  } else {
                    pb3 = txtProgressBar(title = basename(f), label = "information in %", min = 0, max = 100, initial = 1, style = 3)
                  }
                  tryCatch({
                    features = c(features, lapply(1:obj_number, FUN = function(i_obj) {
                      k3 = i_obj/obj_number * 100
                      pb_fun(pb3, title = basename(f), value = k3, label = sprintf("Extracting features information %.0f%%", k3))
                      if((i_obj + obj_shift) %in% objects_1) return(readBin(toread2, "raw", n = feat_number * 4, endian = r_endian))
                      return(as.raw(c()))
                    }))}, finally = close(pb3))
                } else {
                  features = c(features, lapply(1:obj_number, FUN = function(i_obj) {
                    fv = readBin(toread2, "raw", n = feat_number * 4, endian = r_endian)
                    if((i_obj + obj_shift) %in% objects_1) return(readBin(toread2, "raw", n = feat_number * 4, endian = r_endian))
                    return(as.raw(c()))
                  }))
                }
              }, error = function(e) {
                stop(e$message)
              }, finally = close(toread2))
              obj_shift = obj_shift + obj_number
            }
          }, error = function(e) {
            message(paste0(e$message, ". Features values were not exported"))
          })
        }
        features = unlist(features)
        
        # binary features values were extracted recreates tags 33080 and 33082 
        if(length(features) != 0) {
          features = c(writeBin(as.double(L), raw(), size = 4, endian = r_endian), feat_number_r, features)
          feat_off_ifd = list(packBits(intToBits(33080),type="raw"), #tag
                              packBits(intToBits(4),type="raw"), #typ
                              packBits(intToBits(1),type="raw"), #count
                              packBits(intToBits(0),type="raw")) #val/offsets
          feat_bin_ifd = list(packBits(intToBits(33082),type="raw"), #tag
                              packBits(intToBits(4),type="raw"), #typ
                              packBits(intToBits(1),type="raw"), #count
                              packBits(intToBits(1),type="raw")) #val/offsets
          if(endianness!=r_endian) {
            feat_off_ifd = lapply(feat_off_ifd, rev)
            feat_bin_ifd = lapply(feat_bin_ifd, rev)
          }
          feat_off_ifd[[1]] = feat_off_ifd[[1]][1:2]
          feat_off_ifd[[2]] = feat_off_ifd[[2]][1:2]
          feat_bin_ifd[[1]] = feat_bin_ifd[[1]][1:2]
          feat_bin_ifd[[2]] = feat_bin_ifd[[2]][1:2]
          ifd = c(ifd,
                  list(`33080` = list(min_content = unlist(feat_off_ifd),
                                      add_content = features)),
                  list(`33082` = list(min_content = unlist(feat_bin_ifd),
                                      add_content = raw())))
          
        }
        # adds pkg version tag /!\ mandatory to prevent overwriting original file
        pkg_ver = charToRaw(paste0(unlist(packageVersion("IFC")), collapse = "."))
        pkg_ifd = list(packBits(intToBits(33090),type="raw"), #tag
                       packBits(intToBits(2),type="raw"), #typ
                       packBits(intToBits(length(pkg_ver)),type="raw"), #count
                       packBits(intToBits(0),type="raw")) #val/offsets
        if(endianness!=r_endian) {
          pkg_ifd = lapply(pkg_ifd, rev)
        }
        pkg_ifd[[1]] = pkg_ifd[[1]][1:2]
        pkg_ifd[[2]] = pkg_ifd[[2]][1:2]
        ifd = c(ifd,
                list(`33090` = list(min_content = unlist(pkg_ifd),
                                    add_content = pkg_ver)))
        
        # reorders ifd
        ifd = ifd[order(names(ifd))]
        
        # modifies total objects count
        tmp = packBits(intToBits(L),type="raw")
        if(endianness!=r_endian) tmp = rev(tmp)
        ifd[["33018"]]$min_content[9:12] <- tmp
      }
      
      # modifies object id
      tmp = packBits(intToBits(floor(obj_id/2)),type="raw")
      if(endianness!=r_endian) tmp = rev(tmp)
      # TODO ask amnis what to do with 33024
      if(length(ifd[["33024"]])!=0) {
        if(length(ifd[["33003"]])!=0) {
          ifd[["33024"]]$min_content[9:12] <- ifd[["33003"]]$min_content[9:12]
        }
      }
      if(length(ifd[["33003"]])!=0) ifd[["33003"]]$min_content[9:12] <- tmp
      # if(length(ifd[["33024"]])!=0) ifd[["33024"]]$min_content[9:12] <- tmp 

      # defines new offset position of current ifd
      l_min = sum(sapply(ifd, FUN=function(i_tag) length(i_tag$min_content))) + 2
      l_add = sum(sapply(ifd, FUN=function(i_tag) length(i_tag$add_content)))
      
      # writes this new offset
      pos = pos + 4
      tmp = packBits(intToBits(pos + l_add),type="raw")
      if(endianness!=r_endian) tmp = rev(tmp)
      writeBin(object = tmp, con = towrite, endian = r_endian)
      
      # writes all additional content
      writeBin(object = unlist(lapply(ifd, FUN=function(i_tag) i_tag$add_content)), con = towrite, endian = r_endian)
      
      # modifies number of directory entries
      n_entries = length(ifd)
      tmp = packBits(intToBits(n_entries),type="raw")
      if(endianness!=r_endian) tmp = rev(tmp)
      
      # writes modified number of entries
      writeBin(object = tmp[1:2], con = towrite, endian = r_endian)
      
      # modifies ifd val/offset of minimal content 
      for(i in 1:length(ifd)) {
        la = length(ifd[[i]]$add_content)
        if(la==0) next
        tmp = packBits(intToBits(pos),type="raw")
        if(endianness!=r_endian) tmp = rev(tmp)
        ifd[[i]]$min_content[9:12] <- tmp
        pos = pos + la
      }
      
      # writes ifd
      writeBin(object = unlist(lapply(ifd, FUN=function(i_tag) i_tag$min_content)), con = towrite, endian = r_endian)
      pos = pos + l_min 
      obj_id = obj_id + 1
    }
    writeBin(object = packBits(intToBits(0),type="raw"), con = towrite, endian = r_endian)
  }, error = function(e) {
    close(towrite)
    stop(paste0("Can't create 'export_to' file.\n", export_to,
                ifelse(overwritten,"\nFile was not modified.\n","\n"),
                "See pre-file @\n", normalizePath(file_w, winslash = "/", mustWork = FALSE), "\n",
                e$message), call. = FALSE)
  })
  close(towrite)
  if(overwritten) {
    mess = paste0("\n######################\n", export_to, "\nhas been successfully overwritten\n")
    if(!suppressWarnings(file.rename(to = export_to, from = file_w))) { # try file renaming which is faster
      if(!file.copy(to = export_to, from = file_w, overwrite = TRUE)) { # try file.copy if renaming is not possible
        stop(paste0("Can't copy temp file@\n", normalizePath(file_w, winslash = "/"), "\n",
                    "Can't create 'export_to' file.\n", export_to,
                    "\nFile was not modified.\n"), call. = FALSE)
      } else {
        file.remove(file_w, showWarnings = FALSE)
      }
    }
  } else {
    mess = paste0("\n######################\n", export_to, "\nhas been successfully exported\n")
  }
  message(mess)
  return(invisible(export_to))
}
